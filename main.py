**Question 1.** Show how you can detect diagonal edges by designing a simple Prewitt filter for detecting 45° edges in an image.
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

# Define the Prewitt 45° filter
prewitt_45_filter = np.array([
    [-1, -1, 0],
    [-1,  0, 1],
    [ 0,  1, 1]
])

# Load an example image
image = cv2.imread('/content/Assignment_2_Image1.png', cv2.IMREAD_GRAYSCALE)

# Apply the filter using cv2.filter2D
edges_45 = cv2.filter2D(image, -1, prewitt_45_filter)

# Display the original and edge-detected image
plt.figure(figsize=(8, 4))
plt.subplot(1, 2, 1)
plt.imshow(image, cmap='gray')
plt.title('Original Image')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(edges_45, cmap='gray')
plt.title('45° Edge Detection')
plt.axis('off')

plt.show()

"""**Question 2.** Detect the intensity transitions (edges) of the given image by using Laplacian kernel whose central coefficient is 24, and all other coefficients are –1. Implement the filtering from scratch.  \\
Also, sharpen using the below Laplacian of Gaussian kernel (implementation from scratch): Do you see any difference in the results you obtained? If yes, explain the difference.   

![assignment-2_image.png](data:image/png;base64,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NzZr1ozVvc31AML44IMP2EawQevQoYN310gywptuuql58+bPPvus6xklBcziHTt2vPbaa23WCXjKjgDtPPQIaQE80dpcDzBags31ACkCtETYHREQJOOkseAyK5/KKMhONLhkBw4wtAgviFnRQFq+7gNOR96dIum8cp2K7tmhbdWqVU5ODgtKp5XoQPHYsWNMwyxY0fKuaIAFwB2aBZcXdWT279/P6tHvu3gofvfdd6ytGzduzKFTka5o2WHy1/fnInfppZd6iVLgnKenp8sT97vYrlape3xfGRmWvIqQc+m8MUcHimXLliVg1srPPfecv7WyCa5w4cIivABJfSoM+N1DGMhdDO8ruz7AdsIootKyZUunokt26G7QoAF86CJFiojpEeXKlUMRRH+JQsDRyJEjne9grF+/XpOO9/eV2euIYOXivVqRV3Zw1759e+dM55IdaPNziBkZGd5dIml+oY19rPc6d0KnsXbt2jqMDkall7fQ0mc+xXcF8voyBaatadOmORVdsgOHNjMzUz95pkMvkCSbOr+KBlIhxQ8//LB26tEheea42D7wQpyhb7QEZ6dnz57qEKRpWhFeECTpXdHA8hZ4iCXY3MiQvAjTeoGlFxBWqToV82SH+ucKPOecc7zMFKcIzCOxwMxUAAM2sWyezfa7IDt5oCta95OC7LigIDsFiB2B6uFCS01N5d7FypPNA0SlSpX0Mzm65QlciQbwgX1gwRZKKGzTFlj62dQJ2ELJh3FH6xy1euOBbcgCloPGaAslGrb1qCdRC6qlS5dSDJTEaaeddtZZZ0HrdWl6UYQIVA9qVapUCfq971AgJh32tosXL/7222+h5V69AaEEwdgUsXfv3kWLFv3www/QxmO+welu586dSkL8McgCrYht27YxxiNHjkAnaYyyaTkMEFu3buU86rUgeRQ/EurXr6/thaocwq6eiy++mD0XtIouFFLYsWNHhQoV5syZA2ffvn0VK1Z899134aMV3bFfGJuffPJJ+fLlGSfMr776qly5csuXL4dPPJJMKnAEyOyzzz779NNPV6tWzXyxH3zJxAwsKNvjx4/n6tUv7UyfPj0lJYUapdecpEQBa1rQDRs2rHr16qob9vB4Z09Ob9hxiQ/BNus265uS/FUPyjpbTZo0ueqqq5DHMW1OTk6pUqUOWT/yJQeJgoZBMBdccMFdd93F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)

"""

def apply_custom_filter(image, kernel):
    # Convert image to float to avoid overflow/underflow during convolution
    image = image.astype(np.float32)

    # Get the dimensions of the image and kernel
    image_height, image_width = image.shape
    kernel_size = kernel.shape[0]
    pad_size = kernel_size // 2

    # Pad the image using 'reflect' to avoid border issues
    padded_image = np.pad(image, pad_size, mode='reflect')

    # Create an output image to store the results
    output_image = np.zeros_like(image)

    # Convolve the kernel over the image
    for i in range(image_height):
        for j in range(image_width):
            # Extract the region of interest
            region = padded_image[i:i + kernel_size, j:j + kernel_size]
            # Apply the filter (element-wise multiplication and summation)
            output_image[i, j] = np.sum(region * kernel)

    # Normalize the output to the range [0, 255]
    output_image = np.clip(output_image, 0, 255).astype(np.uint8)

    return output_image

# Define the Laplacian kernel with a central coefficient of 24 and -1 elsewhere
laplacian_kernel = np.array([
    [-1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1],
    [-1, -1, 24, -1, -1],
    [-1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1]
])

# Load the image in grayscale
image_path = '/content/Assignment_2_image_2.png'
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Apply the custom Laplacian filter
filtered_image = apply_custom_filter(image, laplacian_kernel)

# Display the original and filtered images
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.imshow(image, cmap='gray')
plt.title('Original Image')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(filtered_image, cmap='gray')
plt.title('Laplacian Edge Detection')
plt.axis('off')

plt.show()

def apply_custom_filter(image, kernel):
    # Convert image to float to avoid overflow/underflow during convolution
    image = image.astype(np.float32)

    # Get the dimensions of the image and kernel
    image_height, image_width = image.shape
    kernel_size = kernel.shape[0]
    pad_size = kernel_size // 2

    # Pad the image using 'reflect' to avoid border issues
    padded_image = np.pad(image, pad_size, mode='reflect')

    # Create an output image to store the results
    output_image = np.zeros_like(image)

    # Convolve the kernel over the image
    for i in range(image_height):
        for j in range(image_width):
            # Extract the region of interest
            region = padded_image[i:i + kernel_size, j:j + kernel_size]
            # Apply the filter (element-wise multiplication and summation)
            output_image[i, j] = np.sum(region * kernel)

    # Normalize the output to the range [0, 255]
    output_image = np.clip(output_image, 0, 255).astype(np.uint8)

    return output_image

# Define the Laplacian of Gaussian (LoG) kernel
log_kernel = np.array([
    [0, 0, -1, 0, 0],
    [0, -1, -2, -1, 0],
    [-1, -2, 16, -2, -1],
    [0, -1, -2, -1, 0],
    [0, 0, -1, 0, 0]
])

# Load the image in grayscale
image_path = '/content/Assignment_2_image_2.png'
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Apply the custom Laplacian of Gaussian filter
sharpened_image = apply_custom_filter(image, log_kernel)

# Display the original and filtered images
plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
plt.imshow(image, cmap='gray')
plt.title('Original Image')
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(sharpened_image, cmap='gray')
plt.title('LoG Sharpened Image')
plt.axis('off')

# Reapply the earlier Laplacian kernel for comparison
laplacian_kernel = np.array([
    [-1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1],
    [-1, -1, 24, -1, -1],
    [-1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1]
])

# Apply the Laplacian filter
laplacian_image = apply_custom_filter(image, laplacian_kernel)

plt.subplot(1, 3, 3)
plt.imshow(laplacian_image, cmap='gray')
plt.title('Laplacian Edge Detection')
plt.axis('off')

plt.show()

"""**Difference in Results:**

LoG Filter: This filter produce edges that are smoother and less affected by noise. The Gaussian smoothing step helps in removing small noise, so only significant edges are detected. \\
Laplacian Filter: Without Gaussian smoothing, the edges detected include noise and finer details, leading to a more cluttered result.

**Question3.** Show how you can use Gaussian smoothing to sharpen an image using a Gaussian filter. Given: Gaussian kernel size 3x3 and standard deviation=1, Equation is given below to implement a Gaussian filter.
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

def gaussian_kernel(size, sigma):
    """Generates a 2D Gaussian kernel."""
    kernel = np.fromfunction(
        lambda x, y: (1/(2*np.pi*sigma**2)) * np.exp(-((x-(size-1)/2)**2 + (y-(size-1)/2)**2) / (2*sigma**2)),
        (size, size)
    )
    return kernel / np.sum(kernel)  # Normalize the kernel

def apply_custom_filter(image, kernel):
    """Applies a custom convolution filter to an image."""
    image = image.astype(np.float32)
    image_height, image_width = image.shape
    kernel_size = kernel.shape[0]
    pad_size = kernel_size // 2

    padded_image = np.pad(image, pad_size, mode='reflect')
    output_image = np.zeros_like(image)

    for i in range(image_height):
        for j in range(image_width):
            region = padded_image[i:i + kernel_size, j:j + kernel_size]
            output_image[i, j] = np.sum(region * kernel)

    return output_image

def unsharp_masking(image, gaussian_kernel):
    """Performs unsharp masking to sharpen an image."""
    # Step 1: Gaussian smoothing (blurring)
    blurred_image = apply_custom_filter(image, gaussian_kernel)

    # Step 2: Create the mask by subtracting the blurred image from the original
    mask = image - blurred_image

    # Step 3: Sharpen the image by adding the mask back to the original
    sharpened_image = np.clip(image + mask, 0, 255).astype(np.uint8)

    return sharpened_image

# Define the Gaussian kernel parameters
kernel_size = 3
sigma = 1

# Generate the Gaussian kernel
gaussian_kernel = gaussian_kernel(kernel_size, sigma)

# Load the image in grayscale
image_path = '/content/Assignment_2_Image1.png'
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Apply unsharp masking
sharpened_image = unsharp_masking(image, gaussian_kernel)

# Display the original and sharpened images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(image, cmap='gray')
plt.title('Original Image')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(sharpened_image, cmap='gray')
plt.title('Sharpened Image (Unsharp Masking)')
plt.axis('off')

plt.show()

"""**Question 4.** Implement Gabor filters at different scales, orientations, and frequencies (from scratch) and use them to detect edges on image (Assignment_2_Image_1.png). For this problem, you can simply use the real part of the complex Gabor filters.
![image.png](data:image/png;base64,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)
"""

def gabor_filter(x, y, sigma, gamma, theta, f0, phi=0):
    """
    Generate a real part of a Gabor filter response.

    Parameters:
    - x, y: 2D coordinate grids.
    - sigma: Standard deviation of the Gaussian envelope.
    - gamma: Spatial aspect ratio of the Gaussian envelope.
    - theta: Orientation of the Gabor filter (in radians).
    - f0: Spatial frequency of the sinusoidal wave.
    - phi: Phase offset of the sinusoidal function.

    Returns:
    - Real part of the Gabor filter.
    """
    # Rotation
    x_theta = x * np.cos(theta) + y * np.sin(theta)
    y_theta = -x * np.sin(theta) + y * np.cos(theta)

    # Gaussian envelope
    gaussian = np.exp(- (x_theta ** 2 + gamma ** 2 * y_theta ** 2) / (2 * sigma ** 2))

    # Sinusoidal wave
    sinusoid = np.cos(2 * np.pi * f0 * x_theta + phi)

    # Gabor filter response
    gabor = gaussian * sinusoid

    return gabor

def apply_gabor_filters(image, sigmas, thetas, f0, gamma=0.5):
    """
    Apply Gabor filters at different scales, orientations, and frequencies to detect edges.

    Parameters:
    - image: Input grayscale image.
    - sigmas: List of standard deviations (σ) to apply the Gabor filters.
    - thetas: List of orientations (θ) to apply the Gabor filters.
    - f0: Spatial frequency of the sinusoidal wave.
    - gamma: Spatial aspect ratio of the Gaussian envelope.

    Returns:
    - List of filtered images.
    """
    kernel_size = 31
    x = np.linspace(-kernel_size // 2, kernel_size // 2, kernel_size)
    y = np.linspace(-kernel_size // 2, kernel_size // 2, kernel_size)
    X, Y = np.meshgrid(x, y)

    filtered_images = []

    for sigma in sigmas:
        for theta in thetas:
            gabor = gabor_filter(X, Y, sigma, gamma, theta, f0)
            filtered_image = cv2.filter2D(image, cv2.CV_64F, gabor)
            filtered_images.append((sigma, theta, filtered_image))

    return filtered_images

# Parameters for Gabor filters
sigmas = [1.0, 3.0]  # Different scales (standard deviations)
thetas = [0, np.pi/4, np.pi/2, 3*np.pi/4]  # 0°, 45°, 90°, 135° in radians
f0 = 0.1  # Spatial frequency

# Load the image and convert to grayscale
image_path = '/content/Assignment_2_Image1.png'
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Apply Gabor filters
filtered_images = apply_gabor_filters(image, sigmas, thetas, f0)

# Plot the results
plt.figure(figsize=(10, 8))
num_filters = len(sigmas) * len(thetas)
for i, (sigma, theta, filtered_image) in enumerate(filtered_images):
    plt.subplot(len(sigmas), len(thetas), i + 1)
    plt.imshow(filtered_image, cmap='gray')
    plt.title(f'Sigma: {sigma}, Theta: {np.rad2deg(theta):.0f}°')
    plt.axis('off')

plt.tight_layout()
plt.show()

# Custom Gabor filter implementation
def gabor_filter(x, y, sigma, gamma, theta, f0, phi=0):
    x_theta = x * np.cos(theta) + y * np.sin(theta)
    y_theta = -x * np.sin(theta) + y * np.cos(theta)
    gaussian = np.exp(- (x_theta ** 2 + gamma ** 2 * y_theta ** 2) / (2 * sigma ** 2))
    sinusoid = np.cos(2 * np.pi * f0 * x_theta + phi)
    gabor = gaussian * sinusoid
    return gabor

def apply_gabor_filters_custom(image, sigmas, thetas, f0, gamma=0.5):
    kernel_size = 31
    x = np.linspace(-kernel_size // 2, kernel_size // 2, kernel_size)
    y = np.linspace(-kernel_size // 2, kernel_size // 2, kernel_size)
    X, Y = np.meshgrid(x, y)
    filtered_images = np.zeros((len(sigmas), image.shape[0], image.shape[1]))
    gabor_kernels = []

    for i, sigma in enumerate(sigmas):
        max_response = np.zeros_like(image, dtype=np.float64)
        for theta in thetas:
            gabor = gabor_filter(X, Y, sigma, gamma, theta, f0)
            gabor_kernels.append(gabor)
            filtered_image = cv2.filter2D(image, cv2.CV_64F, gabor)
            max_response = np.maximum(max_response, filtered_image)
        filtered_images[i] = max_response

    return gabor_kernels, filtered_images

# OpenCV Gabor filter implementation
def apply_gabor_filters_opencv(image, sigmas, thetas, f0, gamma=0.5):
    filtered_images = np.zeros((len(sigmas), image.shape[0], image.shape[1]))
    gabor_kernels = []

    for i, sigma in enumerate(sigmas):
        max_response = np.zeros_like(image, dtype=np.float64)
        for theta in thetas:
            kernel = cv2.getGaborKernel((31, 31), sigma, theta, 1/f0, gamma, 0, ktype=cv2.CV_64F)
            gabor_kernels.append(kernel)
            filtered_image = cv2.filter2D(image, cv2.CV_64F, kernel)
            max_response = np.maximum(max_response, filtered_image)
        filtered_images[i] = max_response

    return gabor_kernels, filtered_images

# Parameters
sigmas = [1.0, 3.0]
thetas = [0, np.pi/4, np.pi/2, 3*np.pi/4]
f0 = 0.1
gamma = 0.5

# Load the image and convert to grayscale
image_path = '/content/Assignment_2_Image1.png'
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Apply custom Gabor filters
gabor_kernels_custom, filtered_images_custom = apply_gabor_filters_custom(image, sigmas, thetas, f0, gamma)

# Apply OpenCV Gabor filters
gabor_kernels_opencv, filtered_images_opencv = apply_gabor_filters_opencv(image, sigmas, thetas, f0, gamma)

# Calculate the number of kernels and images for plotting
total_kernels = len(gabor_kernels_custom)
total_filtered_images = len(sigmas) * 2
total_plots = total_kernels + total_filtered_images
cols = 6  # Increase the number of columns to allow for more plots
rows = int(np.ceil(total_plots / cols))

# Calculate the number of kernels and images for plotting
total_kernels = len(gabor_kernels_custom)
total_filtered_images = len(sigmas) * 2
total_plots = total_kernels * 2 + total_filtered_images  # Account for both sets of kernels
cols = 6
rows = int(np.ceil(total_plots / cols))

# Plotting the results
plt.figure(figsize=(20, 6 * rows))

# Adjust the vertical spacing between rows
plt.subplots_adjust(hspace= 0.01)

# Plotting custom Gabor kernels
for i in range(total_kernels):
    plt.subplot(rows, cols, i + 1)
    plt.imshow(gabor_kernels_custom[i], cmap='gray')
    plt.title(f'Custom Kernel {i+1}')
    plt.axis('off')

# Plotting OpenCV Gabor kernels - Adjust the starting index
for i in range(total_kernels):
    plt.subplot(rows, cols, i + 1 + total_kernels)  # Start from total_kernels + 1
    plt.imshow(gabor_kernels_opencv[i], cmap='gray')
    plt.title(f'OpenCV Kernel {i+1}')
    plt.axis('off')

# Plotting filtered images (Custom) - Adjust the starting index
for i, sigma in enumerate(sigmas):
    plt.subplot(rows, cols, 2 * total_kernels + i * 2 + 1)  # Start from 2 * total_kernels + 1
    plt.imshow(filtered_images_custom[i], cmap='gray')
    plt.title(f'Custom Filtered (σ={sigma})')
    plt.axis('off')

# Plotting filtered images (OpenCV) - Adjust the starting index
for i, sigma in enumerate(sigmas):
    plt.subplot(rows, cols, 2 * total_kernels + i * 2 + 2)  # Start from 2 * total_kernels + 2
    plt.imshow(filtered_images_opencv[i], cmap='gray')
    plt.title(f'OpenCV Filtered (σ={sigma})')
    plt.axis('off')

plt.tight_layout()
plt.show()
